
        <!DOCTYPE html>
        <html lang="ru" dir="ltr">
            <head>
                <meta charset="utf-8">
                <base href="../../../../" />
                
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Конверторы маршрутов | Пользовательские конверторы в Django</title>
                <style type="text/css">
                    body {
                        height: 100vh;
                    }
                </style>
                <link type="text/css" rel="stylesheet" href="../_bundle/vendor.css" />
<link type="text/css" rel="stylesheet" href="../_bundle/app.css" />
                
                
            </head>
            <body class="g-root g-root_theme_light">
                <div id="root"></div>
                <script type="application/javascript">
                   window.STATIC_CONTENT = false
                   window.__DATA__ = {"data":{"leading":false,"toc":{"title":"Пользовательские конверторы в Django","href":"django-user-converters/index.html","navigation":{"logo":{"url":"/","text":"IDE EDU"},"header":{"leftItems":[{"text":"Блог","type":"button","url":"/blog"}]}},"items":[{"name":"Пользовательские конверторы в Django","expanded":true,"items":[{"name":"Конверторы в Django","href":"django-user-converters/Пользовательские конверторы в Django/Пользовательские конверторы в Django/Конверторы в Django/task.html","id":"Конверторы в Django-0-0.4265163945070274"},{"name":"Вопросы для закрепления","items":[{"name":"Вопрос 1","href":"django-user-converters/Пользовательские конверторы в Django/Вопросы для закрепления/Вопрос 1/task.html","id":"Вопрос 1-0-0.5938330017807727"},{"name":"Вопрос 2","href":"django-user-converters/Пользовательские конверторы в Django/Вопросы для закрепления/Вопрос 2/task.html","id":"Вопрос 2-1-0.41707995674026144"},{"name":"Вопрос 3","href":"django-user-converters/Пользовательские конверторы в Django/Вопросы для закрепления/Вопрос 3/task.html","id":"Вопрос 3-2-0.22800800605627725"},{"name":"Вопрос 4","href":"django-user-converters/Пользовательские конверторы в Django/Вопросы для закрепления/Вопрос 4/task.html","id":"Вопрос 4-3-0.06545630113929102"},{"name":"Вопрос 5","href":"django-user-converters/Пользовательские конверторы в Django/Вопросы для закрепления/Вопрос 5/task.html","id":"Вопрос 5-4-0.1952504047167054"}],"id":"Вопросы для закрепления-1-0.6943775138684662"}],"id":"Пользовательские конверторы в Django-0-0.0952285800060404"}],"base":"blog/django-user-converters","deepBase":2,"root":{"title":"Блог","href":"index.yaml","navigation":{"logo":{"url":"/","text":"IDE EDU"},"header":{"leftItems":[{"text":"Блог","type":"button","url":"/blog"}]}},"items":[],"base":"blog","deepBase":1}},"meta":{"metadata":[],"style":[],"script":[]},"assets":[],"headings":[{"title":"Постановка задачи","href":"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#postanovka-zadachi","level":2},{"title":"Преобразователи маршрутов","href":"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#preobrazovateli-marshrutov","level":2},{"title":"Пользовательские преобразователи маршрутов","href":"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#polzovatelskie-preobrazovateli-marshrutov","level":2},{"title":"Подведём итоги","href":"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#podvedyom-itogi","level":2}],"title":"Конверторы маршрутов","terms":{":term_velosiped":"Созданием велосипедов в программировании (и не только) называют решение проблемы, которая уже давно решена.",":term_magicheskie_chisla":"Термин \"магическое число\" обычно относится к значениям (не обязательно числовым), которые появляются прямо в коде программы без каких-либо объяснений или комментариев, почему они именно такие и что они означают.\nЧтобы избежать использования магических чисел, разработчики обычно выносят их в переменные с понятными именами.",":term_format_date":"Этот шаблон даты '%Y/%m/%d' означает, что дата записывается в формате \"год/месяц/день\". В нём:\n- '%Y' представляет год в четырёхзначном формате (например, 1970);\n- '%m' представляет месяц в двухзначном формате, с ведущим нулём при необходимости (например, 01 для января);\n- '%d' представляет день в двухзначном формате, также с ведущим нулём при необходимости (например, 01 для первого числа месяца).\nНапример, дата 1 января 1970 года будет записана как \"1970/01/01\" в этом формате."},"includes":[],"html":"<h2 id=\"postanovka-zadachi\"><a href=\"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#postanovka-zadachi\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Постановка задачи</span></a>Постановка задачи</h2>\n<p>Рассмотрим вымышленный маркетплейс «Кибер-Базар». Он хочет дать продавцам больше статистики о продажах, а именно просматривать список заказов по дате оформления. URL страницы со списком заказов должен содержать дату оформления заказов. Перед нами стоит задача реализовать обработку URL-адресов вида <code>/orders/YYYY/MM/DD/</code> Например, <code>/orders/2023/02/03/</code>.</p>\n<p>Инициализируем новое Django приложение <code>orders</code>. Для простоты считаем, что представлению достаточно знать год, месяц и день, чтобы обработать запрос, получить список заказов по дате оформления и подставить их в шаблон. Тогда представление, основанное на классах (class based view) будет следующим:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> django.views <span class=\"hljs-keyword\">import</span> View\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrdersListView</span>(<span class=\"hljs-title class_ inherited__\">View</span>):\n   <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">self, request, year, month, day</span>):\n       <span class=\"hljs-string\">\"\"\"\n       Представление возвращает список заказов по дате оформления\n      \n       :param year: Год оформления заказа\n       :param month: Месяц оформления заказа\n       :param day: День оформления заказа\n       \"\"\"</span>\n       ...\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"9\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-9\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-9\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-9.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<h2 id=\"preobrazovateli-marshrutov\"><a href=\"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#preobrazovateli-marshrutov\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Преобразователи маршрутов</span></a>Преобразователи маршрутов</h2>\n<p>Составим путь запроса, по которому будем получать список заказов:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs text\">/orders/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;/\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"16\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-16\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-16\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-16.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>где  параметр <code>&lt;year&gt;</code> - запрашиваемый год, <code>&lt;month&gt;</code> - месяц, <code>&lt;day&gt;</code> - день.</p>\n<p>Здесь преобразователи маршрутов (route converters) используются для преобразования части URL в аргументы представления (view).<br />\nТеперь Django понимает, что значение части URL <code>&lt;year&gt;</code> необходимо передать в представление как аргумент <code>year</code> в метод <code>get</code> в классе <code>OrdersListView</code>. Аналогично с аргументами <code>&lt;month&gt;</code> и <code>&lt;day&gt;</code>.</p>\n<p>По умолчанию преобразователи маршрутов возвращают строки, а год должен быть целочисленного значения. Для этого в Django существуют стандартные конвертеры маршрутов:</p>\n<ul>\n<li><code>str</code>: используется для строковых значений, можно не указывать используется по умолчанию.</li>\n<li><code>int</code>: используется для захвата нуля и положительных целочисленных значений. Сразу возвращает тип <code>int</code>.</li>\n<li><code>slug</code>: используется для строковых значений, состоящих из латинских букв, цифр и дефисов.</li>\n<li><code>uuid</code>: используется для значений UUID.</li>\n</ul>\n<p>Эти конвертеры используются следующим образом: <code>&lt;название_конвертера:название_параметра&gt;</code>.<br />\nНапример, стандартный конвертер <code>int</code> можно указать для параметров года, месяца и дня.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> django.urls <span class=\"hljs-keyword\">import</span> path\n\n<span class=\"hljs-keyword\">from</span> orders <span class=\"hljs-keyword\">import</span> views\n\nurlpatterns = [\n    <span class=\"hljs-comment\"># с помощью встроенного преобразователя пути параметры будут провены на совпадение и провалидированы</span>\n    path(<span class=\"hljs-string\">'orders/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/'</span>, views.OrdersListView.as_view()),\n]\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"51\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-51\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-51\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-51.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Минус такого подхода с использованием стандартного конвертера <code>int</code>, в том, что в месяц, например, можно передать число 123, а месяц может быть записан числом не больше чем из двух цифр.</p>\n<p>Каждый стандартный конвертер основан, на <a href=\"https://docs.djangoproject.com/en/4.2/topics/http/urls/#using-regular-expressions\" target=\"_blank\" rel=\"noreferrer noopener\">регулярных выражениях</a>.<br />\nПопробуем написать регулярное выражение, которое будет искать год формата <code>YYYY</code>, то есть обязательно состоять из 4 цифр:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs\">(?P&lt;year&gt;\\d\\d\\d\\d)\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"58\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-58\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-58\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-58.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Здесь были применены именованные скобочные группы, <code>(?P&lt;year&gt;...)</code>, которые позволяют дополнительно захватывать из строки, параметр и дать ему название <code>year</code>. Запись <code>\\d\\d\\d\\d</code> говорит о том, что год должен состоять из 4 цифр.</p>\n<p>Запишем регулярное выражение, которое будет в URL-адресе искать дату формата <code>YYYY/MM/DD</code>:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs\">orders/(?P&lt;year&gt;\\d\\d\\d\\d)/(?P&lt;month&gt;\\d\\d)/(?P&lt;day&gt;\\d\\d)/\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"65\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-65\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-65\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-65.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Чтобы Django правильно мог обрабатывать регулярные выражения внутри пути, вместо <code>path</code> из модуля <code>django.urls</code> следует использовать <code>re_path</code>:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> django.urls <span class=\"hljs-keyword\">import</span> re_path\n\n<span class=\"hljs-keyword\">from</span> orders <span class=\"hljs-keyword\">import</span> views\n\n\nurlpatterns = [\n    <span class=\"hljs-comment\"># маршрут c записанный с использованием регулярных выражений</span>\n    re_path(<span class=\"hljs-string\">r'^orders/(?P&lt;year&gt;\\d\\d\\d\\d)/(?P&lt;month&gt;\\d\\d)/(?P&lt;day&gt;\\d\\d)/$'</span>, views.OrdersListView.as_view()),  \n]\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"69\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-69\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-69\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-69.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p></p>\n<p>Обратите внимание, что при использовании <code>re_path</code> следует использовать дополнительные символы <code>^</code> и <code>$</code> при записи пути. Это так называемые якоря. Символ <code>^</code> означает начало строки, <code>$</code> - конец строки. Они нужны, чтобы регулярное выражение проверяло весь путь целиком, а не пыталось найти его какую-то подчасть.</p>\n<p></p>\n<p>Такой шаблон маршрута даёт более точные URL-адреса, например, месяц 123 больше не будет совпадать, поскольку параметр месяца ограничен длиной ровно две цифры.<br />\nНо теперь каждый захваченный аргумент отправляется в представление в виде строки, независимо от того, какое соответствие создает регулярное выражение.<br />\nА стандартный конвертер <code>int</code> давал целое число.</p>\n<table>\n<thead>\n<tr>\n<th>Стандартный конвертер</th>\n<th>Регулярное выражение</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;</code></td>\n<td><code>(?P&lt;year&gt;\\d\\d\\d\\d)/(?P&lt;month&gt;\\d\\d)/(?P&lt;day&gt;\\d\\d)</code></td>\n</tr>\n<tr>\n<td>Лаконичная запись</td>\n<td>Сложнее воспринимать</td>\n</tr>\n<tr>\n<td>Общая запись</td>\n<td>Более точные пути</td>\n</tr>\n<tr>\n<td>Приведение к нужному типу</td>\n<td>Всегда строка</td>\n</tr>\n</tbody>\n</table>\n<p>Ни в первом ни во втором случае не защиты от дат 2023/02/31 и никак не проверяем их. Делать проверку средствами регулярок точно не стоит.</p>\n<p>Не будем изобретать «<i class=\"yfm yfm-term_title\" term-key=\":term_velosiped\" aria-describedby=\":term_velosiped_element\" id=\"j87vnpcc\">велосипед</i>» и обратимся к типу данных <code>datetime</code> из встроенного модуля <code>datetime</code>.<br />\nСделаем это в представлении:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrdersListView</span>(<span class=\"hljs-title class_ inherited__\">View</span>):\n   <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">self, request, year, month, day</span>):\n       <span class=\"hljs-keyword\">try</span>:\n           date = datetime(year, month, day)  <span class=\"hljs-comment\"># проверяем валидность даты встроенными средствами python</span>\n       <span class=\"hljs-keyword\">except</span> ValueError:\n           <span class=\"hljs-keyword\">raise</span> Http404(...)  <span class=\"hljs-comment\"># возвращаем клиенту ошибку 404 </span>\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"134\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-134\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-134\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-134.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Вроде бы худо бедно пути настроили, обработку и проверку дат сделали. Но что, если через какое-то время надо будет разработать новый функционал веб-приложения, который также завязан на датах? Взять и скопировать?</p>\n<p>Во-первых копировать этот код - плохо, нарушается принцип DRY(don't repeat yourself) не повторяй себя. Во-вторых, \"Thick models, thin views\" (толстые модели, тонкие представления) - это подход в разработке веб-приложений, который состоит в том, чтобы реализовывать большую часть логики в моделях, а в представлениях использовать только необходимые для представления данные.</p>\n<p>Этот подход позволяет отделять логику бизнес-логики от логики представления, что делает код более читаемым и повторно используемым. Он также помогает улучшить тестируемость и уменьшает риск ошибок.</p>\n<p>Но вы скажете, что Django View - это ведь контроллер из модели MVT, а представление это Template, и будете абсолютно правы. В шаблоны точно не будем лезть, а вот соблазн писать много бизнес-логики в Django View всегда есть. Задача Django View принять HTTP запрос, взять данные из модели, подставить их в шаблон и отдать ответ HTTP ответ. Все остальное можно и нужно делегировать.</p>\n<p>Тем самым соблюдая один из пяти принципов SOLID, принципов объектно-ориентированного программирования, рекомендуемых для создания качественного, масштабируемого и поддерживаемого кода. И это принцип единственной ответственности (Single Responsibility Principle, SRP) - каждый класс должен иметь одну ответственность и соответствующие ей методы.</p>\n<h2 id=\"polzovatelskie-preobrazovateli-marshrutov\"><a href=\"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#polzovatelskie-preobrazovateli-marshrutov\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Пользовательские преобразователи маршрутов</span></a>Пользовательские преобразователи маршрутов</h2>\n<p>Ведь правда, что вы стремитесь писать качественный, масштабируемый и поддерживаемый код? К счастью в этом вопросе фреймворк Django предоставляет готовый шаблон, как написать <a href=\"https://docs.djangoproject.com/en/4.2/topics/http/urls/#registering-custom-path-converters\" target=\"_blank\" rel=\"noreferrer noopener\">пользовательский преобразователь путей</a>.<br />\nХорошей практикой считается хранить пользовательские преобразователи путей в модуле <code>converters.py</code> там же, где находится <code>views.py</code>.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-comment\"># orders/converters.py</span>\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserDateConverter</span>:\n    <span class=\"hljs-string\">\"\"\" Пользовательский конвертер маршрутов. \"\"\"</span>\n    regex = <span class=\"hljs-string\">r\"\\d\\d\\d\\d/\\d\\d/\\d\\d\"</span>  <span class=\"hljs-comment\"># объявляем, что захватываем часть строки формата YYYY/MM/DD</span>\n    date_format = <span class=\"hljs-string\">'%Y/%m/%d'</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">to_python</span>(<span class=\"hljs-params\">self, value: <span class=\"hljs-built_in\">str</span></span>):\n        <span class=\"hljs-string\">\"\"\" Метод обрабатывает захваченную регуляркой строку в python тип, который должен быть передан Django View. \"\"\"</span>\n        <span class=\"hljs-keyword\">return</span> datetime.strptime(value, self.date_format)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">to_url</span>(<span class=\"hljs-params\">self, value: datetime</span>):\n        <span class=\"hljs-string\">\"\"\" Метод обрабатывает python тип, и возвращает строку, которая будет подставлена в url. \"\"\"</span>\n        <span class=\"hljs-keyword\">return</span> value.strftime(self.date_format)\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"156\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-156\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-156\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-156.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Фреймворк Django диктует свои строгие правила:</p>\n<ul>\n<li><code>regex</code> - атрибут класса, который содержит регулярное выражение, которое будет использоваться для захвата параметра;</li>\n<li><code>to_python</code> - метод, которые принимает в качестве аргумента строку (так как регулярное выражение всегда возвращает строку) и преобразует его в необходимый тип данных. Результат метода будет передан соответствующему аргументу в методе обработчике в Django View;</li>\n<li><code>to_url</code> - метод, который принимает объект, который должен быть преобразован в строку для дальнейшей подстановки в url. Например, при вызове тега <a href=\"https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#url\" target=\"_blank\" rel=\"noreferrer noopener\">url</a> внутри шаблона.</li>\n</ul>\n<p>Эти атрибут и методы Django использует при работе с преобразователями маршрутов.</p>\n<div class=\"yfm-note yfm-accent-tip\" note-type=\"tip\"><p class=\"yfm-note-title\">Совет</p>\n<div class=\"yfm-note-content\"><p>Если вы хотите больше примеров, то в <a href=\"https://github.com/django/django/blob/main/django/urls/converters.py\" target=\"_blank\" rel=\"noreferrer noopener\">исходниках</a> Django можно посмотреть как устроены встроенные конверторы.<br />\nЗагляните туда.</p>\n</div></div><p>Давайте подробно рассмотрим, что было выполнено в данном куске кода. Атрибут класса <code>regex</code> хранит регулярное выражение, которое будет искать дату формата <code>YYYY/MM/DD</code>.</p>\n<p>В методе <code>to_python</code> реализована вся логика по обработке и проверке даты, вместо того, чтобы это делать в Django View. Значение в аргументе <code>value</code>, представляющее собой строку, будет разобрано с помощью метода <a href=\"https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior\" target=\"_blank\" rel=\"noreferrer noopener\"><code>strptime</code></a> объекта <code>datetime</code> по шаблону даты, находящемуся в атрибуте <code>date_format</code>.<br />\nDjango полон «козырей в рукаве», и если внутри метода <code>to_python</code> возникает ошибка <code>ValueError</code>, то конвертер маршрутов интерпретирует это как ошибку 404 и вернет ее клиенту. Ошибку <code>ValueError</code> как раз вернёт метод <code>strptime</code> при преобразовании некорректной строки с датой в объект даты. Например 2023/02/31.</p>\n<div class=\"yfm-note yfm-accent-alert\" note-type=\"alert\"><p class=\"yfm-note-title\">Внимание</p>\n<div class=\"yfm-note-content\"><p>Появление ошибки <code>ValueError</code> в методе <code>to_python</code> передаёт обработку запроса следующим маршрутам в <code>urlpatterns</code>, а если их больше не осталось то пользователю вернётся ошибка 404, что запрашиваемый ресурс не найден.<br />\nЛюбая ошибка отличная от <code>ValueError</code> будет интерпретирована как ошибка со статус кодом 500 - внутренняя ошибка сервера, и обработка остальным маршрутам не будет передана.</p>\n</div></div><p>Атрибут класса <code>date_format</code> Django использовать не будет, но позволит избавиться от «<i class=\"yfm yfm-term_title\" term-key=\":term_magicheskie_chisla\" aria-describedby=\":term_magicheskie_chisla_element\" id=\"66eeh9um\">магический чисел</i>». Запись <i class=\"yfm yfm-term_title\" term-key=\":term_format_date\" aria-describedby=\":term_format_date_element\" id=\"76wpker1\">%Y/%m/%d</i> равносильно формату даты YYYY/MM/DD, и нужна чтобы правильно разобрать по составляющим кусочкам дату.</p>\n<p>Метод <code>to_url</code> реализует обратную задачу метода <code>to_python</code>. Данный метод вызывается, например, когда вы используете тег <code>url</code> внутри шаблонов.</p>\n<p>Написать конвертер маршрутов не достаточно, его ещё нужно зарегистрировать. Делается это в файле <code>urls.py</code>:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-comment\"># orders/urls.py</span>\n<span class=\"hljs-keyword\">from</span> django.urls <span class=\"hljs-keyword\">import</span> path, register_converter\n\n<span class=\"hljs-keyword\">from</span> orders <span class=\"hljs-keyword\">import</span> views, converters\n\n<span class=\"hljs-comment\"># регистрируем пользовательский конвертер</span>\nregister_converter(converters.UserDateConverter, <span class=\"hljs-string\">'date'</span>)\n\n\nurlpatterns = [\n    <span class=\"hljs-comment\"># проверка и получение параметра пути c помощью пользовательского конвертера date</span>\n    path(<span class=\"hljs-string\">'orders/&lt;date:dt&gt;/'</span>, views.OrdersListView.as_view()),\n]\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"215\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-215\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-215\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-215.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Здесь из модуля <code>django.urls</code> импортирована функция <code>register_converter</code>. Эта функция принимает два аргумента:</p>\n<ul>\n<li>Первый аргумент - это класс пользовательского конвертера. В данном случае это <code>UserDateConverter</code> из модуля <code>converters</code>.</li>\n<li>Второй аргумент - это строка, представляющая название конвертера. В данном случае это <code>date</code>.<br />\nЭтот вызов указывает Django, что когда встречается пользовательский конвертер с именем <code>date</code> в URL-пути, должен использоваться класс <code>UserDateConverter</code>, чтобы выполнить преобразование.</li>\n</ul>\n<h2 id=\"podvedyom-itogi\"><a href=\"django-user-converters/Пользовательские%20конверторы%20в%20Django/Пользовательские%20конверторы%20в%20Django/Конверторы%20в%20Django/task.html#podvedyom-itogi\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Подведём итоги</span></a>Подведём итоги</h2>\n<p>Иногда встроенных конвертеров маршрутов ставится недостаточно и приходится прибегать к регулярным выражениям, чтобы точнее определять, какой обработчик нужно вызвать по указанному URL-адресу.</p>\n<p>Регулярные выражения куда сложнее для восприятия, нежели конвертеры маршрутов. Не говоря уже о том, что писать какую-то логику в регулярных выражениях, например, проверку корректности даты, что определенный месяц содержит нужное количество дней, да ещё и с учетом високосного года, становится большой проблемой.</p>\n<p>Создав пользовательский конвертер маршрутов в виде отдельного класса, можно убить двух зайцев: избавиться от сложных регулярных выражений внутри <code>urlpatterns</code> и проверять валидности переданных параметров в Django View.</p>\n<p>Отдельный класс для преобразования маршрутов - это соблюдение одного из принципов SOLID.</p>\n<p>Регулярное выражение в атрибуте класса <code>regex</code>, будет отвечать за первичный захват параметров, а дальше в методе <code>to_python</code> следует проверить валидность параметров и преобразовать значение в нужный тип данных.<br />\nЕсли параметры не отвечают нужному запросу, метод должен поднимать встроенную ошибку <code>ValueError</code>, которая вернется клиенту ошибкой 404, если запрашиваемый ресурс не будет найден.</p>\n<template id=\":term_velosiped_template\" label=\"term_velosiped\"><dfn class=\"yfm yfm-term_dfn\" id=\":term_velosiped_element\" role=\"tooltip\"><p>Созданием велосипедов в программировании (и не только) называют решение проблемы, которая уже давно решена.</p>\n</dfn></template><template id=\":term_magicheskie_chisla_template\" label=\"term_magicheskie_chisla\"><dfn class=\"yfm yfm-term_dfn\" id=\":term_magicheskie_chisla_element\" role=\"tooltip\"><p>Термин \"магическое число\" обычно относится к значениям (не обязательно числовым), которые появляются прямо в коде программы без каких-либо объяснений или комментариев, почему они именно такие и что они означают.<br />\nЧтобы избежать использования магических чисел, разработчики обычно выносят их в переменные с понятными именами.</p>\n</dfn></template><template id=\":term_format_date_template\" label=\"term_format_date\"><dfn class=\"yfm yfm-term_dfn\" id=\":term_format_date_element\" role=\"tooltip\"><p>Этот шаблон даты '%Y/%m/%d' означает, что дата записывается в формате \"год/месяц/день\". В нём:</p>\n<ul>\n<li>'%Y' представляет год в четырёхзначном формате (например, 1970);</li>\n<li>'%m' представляет месяц в двухзначном формате, с ведущим нулём при необходимости (например, 01 для января);</li>\n<li>'%d' представляет день в двухзначном формате, также с ведущим нулём при необходимости (например, 01 для первого числа месяца).<br />\nНапример, дата 1 января 1970 года будет записана как \"1970/01/01\" в этом формате.</li>\n</ul>\n</dfn></template>"},"router":{"pathname":"django-user-converters/Пользовательские конверторы в Django/Пользовательские конверторы в Django/Конверторы в Django/task.html"},"lang":"ru","langs":["ru"]};
                </script>
                <script type="application/javascript" src="../_bundle/react.js"></script>
<script type="application/javascript" src="../_bundle/app.js"></script>
<script type="application/javascript" src="../_bundle/vendor.js"></script>
            </body>
        </html>
    