
        <!DOCTYPE html>
        <html lang="ru" dir="ltr">
            <head>
                <meta charset="utf-8">
                <base href="../../../" />
                
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Создание и обновление объектов | Разработка REST API с помощью Django REST Framework</title>
                <style type="text/css">
                    body {
                        height: 100vh;
                    }
                </style>
                <link type="text/css" rel="stylesheet" href="../_bundle/vendor.css" />
<link type="text/css" rel="stylesheet" href="../_bundle/app.css" />
                
                
            </head>
            <body class="g-root g-root_theme_light">
                <div id="root"></div>
                <script type="application/javascript">
                   window.STATIC_CONTENT = false
                   window.__DATA__ = {"data":{"leading":false,"toc":{"title":"Разработка REST API с помощью Django REST Framework","href":"index.html","navigation":{"logo":{"url":"./index.html","text":"IDE EDU","target":"_self"}},"items":[{"name":"Введение в курс","href":"course.html","id":"Введение в курс-0-0.5893224281734553"},{"name":"Основы ORM в Django","expanded":true,"items":[{"name":"Введение в модуль","href":"Основы ORM в Django/section.html","id":"Введение в модуль-0-0.39551859762922614"},{"name":"ORM модели","items":[{"name":"Введение в модели Django","href":"Основы ORM в Django/ORM модели/Введение в модели Django/task.html","id":"Введение в модели Django-0-0.7244241786391297"},{"name":"Работа с миграциями данных","href":"Основы ORM в Django/ORM модели/Работа с миграциями данных/task.html","id":"Работа с миграциями данных-1-0.7392616842997342"},{"name":"Хорошие практики по работе с миграциями","href":"Основы ORM в Django/ORM модели/Хорошие практики по работе с миграциями/task.html","id":"Хорошие практики по работе с миграциями-2-0.34402946947703983"},{"name":"Основные типы полей и их особенности","href":"Основы ORM в Django/ORM модели/Основные типы полей и их особенности/task.html","id":"Основные типы полей и их особенности-3-0.5960455526439008"},{"name":"Добавление данных через фикстуры","href":"Основы ORM в Django/ORM модели/Добавление данных через фикстуры/task.html","id":"Добавление данных через фикстуры-4-0.41350718279110366"}],"id":"ORM модели-1-0.1772666658733204"},{"name":"CRUD операции","items":[{"name":"Чтение данных","href":"Основы ORM в Django/CRUD операции/Чтение данных/task.html","id":"Чтение данных-0-0.7572391259454849"},{"name":"Создание и обновление объектов","href":"Основы ORM в Django/CRUD операции/Создание и обновление объектов/task.html","id":"Создание и обновление объектов-1-0.53725875985476"},{"name":"Удаление объектов","href":"Основы ORM в Django/CRUD операции/Удаление объектов/task.html","id":"Удаление объектов-2-0.8179573534110112"}],"id":"CRUD операции-2-0.6961637707827337"},{"name":"Работа с админкой","items":[{"name":"Основы работы с админкой","href":"Основы ORM в Django/Работа с админкой/Основы работы с админкой/task.html","id":"Основы работы с админкой-0-0.9963219947580091"},{"name":"Настройка отображения экземпляров моделей в админ панели","href":"Основы ORM в Django/Работа с админкой/Настройка отображения экземпляров моделей в админ панели/task.html","id":"Настройка отображения экземпляров моделей в админ панели-1-0.5466246183583665"},{"name":"Основы работы с админкой","href":"Основы ORM в Django/Работа с админкой/Дополнительные настройки админки/task.html","id":"Основы работы с админкой-2-0.8456550448272611"}],"id":"Работа с админкой-3-0.4944394686122746"}],"id":"Основы ORM в Django-1-0.6282715360959976"},{"name":"Расширенные возможности ORM в Django","items":[{"name":"Введение в модуль","href":"Расширенные возможности ORM в Django/section.html","id":"Введение в модуль-0-0.10430649347963672"},{"name":"Отладка запросов","items":[{"name":"Установка и настройка Debug Toolbar","href":"Расширенные возможности ORM в Django/Отладка запросов/Установка и настройка Debug Toolbar/task.html","id":"Установка и настройка Debug Toolbar-0-0.7630515673089606"},{"name":"Практические примеры использования debugsqlshell","href":"Расширенные возможности ORM в Django/Отладка запросов/Практические примеры использования debugsqlshell/task.html","id":"Практические примеры использования debugsqlshell-1-0.2688605236863135"}],"id":"Отладка запросов-1-0.6679085978310189"},{"name":"Отношения между моделями","items":[{"name":"Отношение многие к одному","href":"Расширенные возможности ORM в Django/Отношения между моделями/Отношение многие к одному/task.html","id":"Отношение многие к одному-0-0.27765151885838923"},{"name":"Отношение один ко многим","href":"Расширенные возможности ORM в Django/Отношения между моделями/Отношение один ко многим/task.html","id":"Отношение один ко многим-1-0.7199175039070416"},{"name":"Отношение многие ко многим","href":"Расширенные возможности ORM в Django/Отношения между моделями/Отношение многие ко многим/task.html","id":"Отношение многие ко многим-2-0.17045615100474865"}],"id":"Отношения между моделями-2-0.07509239179264449"},{"name":"Фильтрация и запросы с помощью Q-объектов","items":[{"name":"Фильтрация по полям модели и связанным моделям","href":"Расширенные возможности ORM в Django/Фильтрация и запросы с помощью Q-объектов/Фильтрация по полям модели и связанным моделям/task.html","id":"Фильтрация по полям модели и связанным моделям-0-0.1398710832606742"},{"name":"Использование Q-объектов для сложных запросов","href":"Расширенные возможности ORM в Django/Фильтрация и запросы с помощью Q-объектов/Использование Q-объектов для сложных запросов/task.html","id":"Использование Q-объектов для сложных запросов-1-0.7323563932844022"},{"name":"Группировка данных и агрегация","href":"Расширенные возможности ORM в Django/Фильтрация и запросы с помощью Q-объектов/Группировка данных и агрегация/task.html","id":"Группировка данных и агрегация-2-0.3679389685936625"}],"id":"Фильтрация и запросы с помощью Q-объектов-3-0.7090114412218711"},{"name":"Оптимизация запросов","items":[{"name":"Подводные камни при работе с ORM запросами","href":"Расширенные возможности ORM в Django/Оптимизация запросов/Подводные камни при работе с ORM запросами/task.html","id":"Подводные камни при работе с ORM запросами-0-0.23718248027766653"},{"name":"Выбор полей запроса","href":"Расширенные возможности ORM в Django/Оптимизация запросов/Выбор полей запроса/task.html","id":"Выбор полей запроса-1-0.36973979889028663"},{"name":"Массовое создание и обновление","href":"Расширенные возможности ORM в Django/Оптимизация запросов/Массовое создание и обновление/task.html","id":"Массовое создание и обновление-2-0.7080178071340659"}],"id":"Оптимизация запросов-4-0.05356891968112243"}],"id":"Расширенные возможности ORM в Django-2-0.07205917149589092"},{"name":"Основы разработки REST API","items":[{"name":"Введение в модуль","href":"Основы разработки REST API/section.html","id":"Введение в модуль-0-0.6337066040670052"},{"name":"Введение в REST API","items":[{"name":"Введение в RESTful API","href":"Основы разработки REST API/Введение в REST API/Введение в RESTful API/task.html","id":"Введение в RESTful API-0-0.4738249252563116"},{"name":"Endpoint и CRUD операции в REST API","href":"Основы разработки REST API/Введение в REST API/Endpoint и CRUD операции в REST API/task.html","id":"Endpoint и CRUD операции в REST API-1-0.9954259395900198"},{"name":"Введение в Django REST Framework","href":"Основы разработки REST API/Введение в REST API/Введение в Django REST Framework/task.html","id":"Введение в Django REST Framework-2-0.2815385831236301"}],"id":"Введение в REST API-1-0.16912343920848238"},{"name":"Сериализаторы в Django REST Framework","items":[{"name":"Сериализаторы в DRF","href":"Основы разработки REST API/Сериализаторы в Django REST Framework/Сериализаторы в DRF/task.html","id":"Сериализаторы в DRF-0-0.13457894741689214"},{"name":"Модельные и вложенные сериализаторы","href":"Основы разработки REST API/Сериализаторы в Django REST Framework/Модельные и вложенные сериализаторы/task.html","id":"Модельные и вложенные сериализаторы-1-0.38026009504340785"}],"id":"Сериализаторы в Django REST Framework-2-0.44439732688890143"},{"name":"APIView в Django REST Framework","items":[{"name":"Применение статусных кодов в REST API","href":"Основы разработки REST API/APIView в Django REST Framework/Применение статусных кодов в REST API/task.html","id":"Применение статусных кодов в REST API-0-0.1488451236835613"},{"name":"Список объектов и добавление новых объектов","href":"Основы разработки REST API/APIView в Django REST Framework/Список объектов и добавление новых объектов/task.html","id":"Список объектов и добавление новых объектов-1-0.676964749610558"},{"name":"Детальная работа с объектом","href":"Основы разработки REST API/APIView в Django REST Framework/Детальная работа с объектом/task.html","id":"Детальная работа с объектом-2-0.10600490144201813"}],"id":"APIView в Django REST Framework-3-0.5294245318652415"}],"id":"Основы разработки REST API-3-0.7804880688969908"},{"name":"Тестирование и типовые API","items":[{"name":"Введение в модуль","href":"Тестирование и типовые API/section.html","id":"Введение в модуль-0-0.664144410016277"},{"name":"Введение в тестирование","items":[{"name":"Test-Driven Development (TDD)","href":"Тестирование и типовые API/Введение в тестирование/Test-Driven Development (TDD)/task.html","id":"Test-Driven Development (TDD)-0-0.627614130620471"},{"name":"Написание, выполнение и завершение тестов","href":"Тестирование и типовые API/Введение в тестирование/Написание, выполнение и завершение тестов/task.html","id":"Написание, выполнение и завершение тестов-1-0.5298134191822943"}],"id":"Введение в тестирование-1-0.5860185805421871"},{"name":"Тестирование в Django","items":[{"name":"Тестирование в Django","href":"Тестирование и типовые API/Тестирование в Django/Тестирование в Django/task.html","id":"Тестирование в Django-0-0.7423659083454581"}],"id":"Тестирование в Django-2-0.48163143140143094"},{"name":"Типовые (generic) API","items":[{"name":"GenericAPIView","href":"Тестирование и типовые API/Типовые (generic) API/GenericAPIView/task.html","id":"GenericAPIView-0-0.6437574165888609"},{"name":"OpenAPI документация","href":"Тестирование и типовые API/Типовые (generic) API/OpenAPI документация/task.html","id":"OpenAPI документация-1-0.6258561289849793"},{"name":"Фильтрация, поиск и пагинация","href":"Тестирование и типовые API/Типовые (generic) API/Фильтрация, поиск и пагинация/task.html","id":"Фильтрация, поиск и пагинация-2-0.48236876704655796"}],"id":"Типовые (generic) API-3-0.19198010695356338"}],"id":"Тестирование и типовые API-4-0.8532383515591158"}],"base":"django-web-api"},"meta":{"metadata":[],"style":[],"script":[]},"assets":[],"headings":[{"title":"Цель урока","href":"#cel-uroka","level":2},{"title":"Метод save()","href":"#metod","level":2,"items":[{"title":"Создание нового объекта с помощью save()","href":"#sozdanie-novogo-obuekta-s-pomoshyu","level":3},{"title":"Обновление существующего объекта с помощью save()","href":"#obnovlenie-sushestvuyushego-obuekta-s-pomoshyu","level":3},{"title":"Параметры метода save()","href":"#parametry-metoda","level":3},{"title":"Сигналы в Django","href":"#signaly-v-django","level":3}]},{"title":"Метод create()","href":"#metod1","level":2,"items":[{"title":"Как использовать метод create()","href":"#kak-ispolzovat-metod","level":3}]},{"title":"Метод update()","href":"#metod2","level":2,"items":[{"title":"Использование метода update() для массового обновления записей","href":"#ispolzovanie-metoda-dlya-massovogo-obnovleniya-zapisej","level":3},{"title":"Состояние гонки и как с ним бороться","href":"#sostoyanie-gonki-i-kak-s-nim-borotsya","level":3},{"title":"update vs save","href":"#update-vs-save","level":3}]}],"title":"Создание и обновление объектов","includes":[],"html":"<h2 id=\"cel-uroka\"><a href=\"#cel-uroka\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Цель урока</span></a>Цель урока</h2>\n<p>В этом уроке вы научитесь использовать Django ORM для создания и обновления объектов в базе данных. Вы узнаете, как применять методы <code>create()</code> и <code>save()</code> для добавления новых записей, а также освоите техники обновления существующих объектов. Мы также обсудим, как предотвратить состояние гонки при обновлении объектов и как использовать сигналы Django для отслеживания изменений в объектах. Кроме того, рассмотрим метод <code>update()</code> и практики массового добавления и обновления объектов для оптимизации производительности.</p>\n<h2 id=\"metod\"><a href=\"#metod\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Метод </span></a>Метод <code>save()</code></h2>\n<p>Метод <code>save()</code> является одним из основных способов сохранения изменений объекта модели в базе данных в Django. Он используется как для добавления новых объектов, так и для обновления существующих записей.</p>\n<p>Вот модель книги</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-comment\"># books/models.py</span>\n\n...\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Book</span>(models.Model):\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookType</span>(models.TextChoices):\n        HARDCOVER = <span class=\"hljs-string\">'HC'</span>, <span class=\"hljs-string\">'Твердая обложка'</span>\n        PAPERBACK = <span class=\"hljs-string\">'PB'</span>, <span class=\"hljs-string\">'Мягкая обложка'</span>\n        EBOOK = <span class=\"hljs-string\">'EB'</span>, <span class=\"hljs-string\">'Электронная книга'</span>\n    title = models.CharField(max_length=<span class=\"hljs-number\">100</span>)\n    year = models.SmallIntegerField(null=<span class=\"hljs-literal\">True</span>, blank=<span class=\"hljs-literal\">True</span>)\n    description = models.TextField(default=<span class=\"hljs-string\">''</span>)\n    book_type = models.CharField(\n        max_length=<span class=\"hljs-number\">2</span>,\n        choices=BookType.choices,\n        default=BookType.PAPERBACK\n    )\n    created_at = models.DateTimeField(auto_now_add=<span class=\"hljs-literal\">True</span>)\n    updated_at = models.DateTimeField(auto_now=<span class=\"hljs-literal\">True</span>)\n    slug = models.SlugField(max_length=<span class=\"hljs-number\">100</span>, unique=<span class=\"hljs-literal\">True</span>)\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"15\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-15\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-15\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-15.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<h3 id=\"sozdanie-novogo-obuekta-s-pomoshyu\"><a href=\"#sozdanie-novogo-obuekta-s-pomoshyu\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Создание нового объекта с помощью </span></a>Создание нового объекта с помощью <code>save()</code></h3>\n<p>Для создания нового объекта сначала создается экземпляр модели, заполняются все обязательные поля, после чего вызывается метод <code>save()</code> для сохранения объекта в базе данных.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> books.models <span class=\"hljs-keyword\">import</span> Book\n\nnew_book = Book(title=<span class=\"hljs-string\">\"New Book Title\"</span>, slug=<span class=\"hljs-string\">\"new-book-title\"</span>)  <span class=\"hljs-comment\"># Создание нового объекта в Python, но не в БД</span>\n<span class=\"hljs-built_in\">print</span>(new_book.pk)  <span class=\"hljs-comment\"># В данном случае будет None, так как объект еще не сохранен</span>\n\nnew_book.save()  <span class=\"hljs-comment\"># Сохранение новой книги в базе данных</span>\n<span class=\"hljs-built_in\">print</span>(new_book.pk)  <span class=\"hljs-comment\"># После сохранения в базе данных объекту присваивается первичный ключ</span>\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"22\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-22\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-22\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-22.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Этот код создает новый объект книги с указанным названием и slug. Затем он выводит значение первичного ключа (primary key) этого объекта до и после его сохранения в базе данных. Его значение можно получить через атрибут <code>pk</code> объекта.</p>\n<p>При вывод первичного ключа новой книги до сохранения будет <code>None</code>, так как объект еще не сохранен. После сохранения в базе данных объекту присваивается первичный ключ</p>\n<aside>\nℹ️ Независимо от того, определяете ли вы поле первичного ключа самостоятельно или позволяете Django предоставить его вам, каждая модель будет иметь свойство с именем `pk`. Он ведет себя как обычный атрибут модели, но на самом деле является псевдонимом любого атрибута, который является полем первичного ключа модели. Вы можете прочитать и установить это значение, как и любой другой атрибут, и оно обновит правильное поле в модели.\n</aside>\n<h3 id=\"obnovlenie-sushestvuyushego-obuekta-s-pomoshyu\"><a href=\"#obnovlenie-sushestvuyushego-obuekta-s-pomoshyu\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Обновление существующего объекта с помощью </span></a>Обновление существующего объекта с помощью <code>save()</code></h3>\n<p>Для обновления объекта сначала извлекается объект из базы данных, модифицируются поля, и затем изменения сохраняются с помощью <code>save()</code>.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> books.models <span class=\"hljs-keyword\">import</span> Book\n\nbook = Book.objects.order_by(<span class=\"hljs-string\">\"pk\"</span>).last()  <span class=\"hljs-comment\"># Получаем последнюю книгу из базы данных по первичному ключу</span>\n<span class=\"hljs-built_in\">print</span>(book.year)  <span class=\"hljs-comment\"># Год издания книги до обновления</span>\n\nbook.year = <span class=\"hljs-number\">2023</span>  <span class=\"hljs-comment\"># Обновляем год издания книги</span>\nbook.save()  <span class=\"hljs-comment\"># Сохраняем изменения в базе данных</span>\n<span class=\"hljs-built_in\">print</span>(book.year)  <span class=\"hljs-comment\"># Обновленный год издания книги</span>\n\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"37\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-37\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-37\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-37.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Этот код загружает последнюю книгу из базы данных, выводит ее год издания, затем обновляет год издания на 2024 и сохраняет изменения в базе данных. После сохранения код снова выводит год издания книги, чтобы показать обновленное значение.</p>\n<h3 id=\"parametry-metoda\"><a href=\"#parametry-metoda\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Параметры метода </span></a>Параметры метода <code>save()</code></h3>\n<p>Метод <code>save()</code> может принимать различные параметры, которые контролируют его поведение, например, <code>force_insert</code> (принудительное добавление новой записи, даже если объект уже существует) и <code>force_update</code> (принудительное обновление, предполагая, что объект уже существует).</p>\n<aside>\nℹ️ Подробнее об этих параметрах можно узнать в [документации](https://docs.djangoproject.com/en/4.2/ref/models/instances/#django.db.models.Model.save).\n</aside>\n<p>Рассмотрим подробнее параметр <code>update_fields</code>, который позволяет указать список полей, которые нужно обновить. Это может быть полезно для оптимизации производительности, так как обновляются только указанные поля, а не весь объект целиком.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> books.models <span class=\"hljs-keyword\">import</span> Book\n\nbook = Book.objects.order_by(<span class=\"hljs-string\">\"pk\"</span>).last()\n\nbook.year = <span class=\"hljs-number\">2024</span>\nbook.save(update_fields=[<span class=\"hljs-string\">\"year\"</span>)  <span class=\"hljs-comment\"># Сохраняем изменения только для поля year</span>\n<span class=\"hljs-built_in\">print</span>(book.year)\n\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"52\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-52\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-52\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-52.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Использование <code>update_fields</code> особенно актуально в ситуациях, когда работа идет с большими моделями или когда необходимо точно контролировать, какие именно изменения применяются к объекту. Это не только уменьшает нагрузку на базу данных, но и повышает читаемость кода, делая явными изменяемые аспекты объекта.</p>\n<h3 id=\"signaly-v-django\"><a href=\"#signaly-v-django\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Сигналы в Django</span></a>Сигналы в Django</h3>\n<p>Сигналы в Django — это механизм, позволяющий компонентам приложения получать уведомления о различных событиях. Сигналы могут быть использованы для выполнения дополнительных действий при создании, обновлении или удалении объектов моделей.</p>\n<aside>\nℹ️ Перечень встроенных сигналов можно найти в официальной [документации](https://docs.djangoproject.com/en/4.2/ref/signals/).\n</aside>\n<p>Сигналы позволяют автоматизировать реакцию на изменения в объектах моделей. Например, вы можете использовать сигнал <code>post_save</code> для выполнения каких-либо действий сразу после сохранения объекта модели.</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> django.db.models.signals <span class=\"hljs-keyword\">import</span> post_save\n<span class=\"hljs-keyword\">from</span> django.dispatch <span class=\"hljs-keyword\">import</span> receiver\n\n<span class=\"hljs-keyword\">from</span> books.models <span class=\"hljs-keyword\">import</span> Book\n\n<span class=\"hljs-meta\">@receiver(<span class=\"hljs-params\">post_save, sender=Book</span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">book_post_save</span>(<span class=\"hljs-params\">sender, instance, created, **kwargs</span>):\n    <span class=\"hljs-keyword\">if</span> created:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Новая книга создана: <span class=\"hljs-subst\">{instance.title}</span>\"</span>)\n    <span class=\"hljs-keyword\">else</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Книга обновлена: <span class=\"hljs-subst\">{instance.title}</span>\"</span>)\n\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"67\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-67\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-67\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-67.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>В этом примере с помощью сигнала <code>post_save</code> мы отслеживаем создание новых книг и обновление существующих, выводя соответствующее сообщение в консоль.</p>\n<h2 id=\"metod1\"><a href=\"#metod1\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Метод </span></a>Метод <code>create()</code></h2>\n<h3 id=\"kak-ispolzovat-metod\"><a href=\"#kak-ispolzovat-metod\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Как использовать метод </span></a>Как использовать метод <code>create()</code></h3>\n<p>Метод <code>create()</code> является удобным способом для создания и сохранения нового объекта в базу данных в один шаг. Этот метод предоставляется менеджером модели и позволяет создать новый объект, автоматически заполнив его поля данными, переданными в <code>create()</code> в качестве аргументов, и сразу же сохранить объект в базе данных.</p>\n<p>Используя ранее определенную модель <code>Book</code>, можно создать новую книгу следующим образом:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> books.models <span class=\"hljs-keyword\">import</span> Book\n\n<span class=\"hljs-comment\"># Создание и сохранение новой книги в базу данных</span>\nnew_book = Book.objects.create(title=<span class=\"hljs-string\">\"Story\"</span>, year=<span class=\"hljs-number\">2024</span>, slug=<span class=\"hljs-string\">\"story\"</span>)\n<span class=\"hljs-built_in\">print</span>(new_book)\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"83\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-83\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-83\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-83.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<h2 id=\"metod2\"><a href=\"#metod2\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Метод </span></a>Метод <code>update()</code></h2>\n<p>Метод <code>update()</code> в Django ORM предназначен для массового обновления записей в базе данных, соответствующих определенным критериям фильтрации. Этот метод позволяет изменить одно или несколько полей для всех объектов, возвращаемых queryset'ом, без необходимости итерировать по каждому объекту индивидуально.</p>\n<p>Это эффективный способ массового обновления данных, так как операция выполняется на уровне базы данных, не требуя загрузки и сохранения каждого объекта в Python код.</p>\n<h3 id=\"ispolzovanie-metoda-dlya-massovogo-obnovleniya-zapisej\"><a href=\"#ispolzovanie-metoda-dlya-massovogo-obnovleniya-zapisej\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Использование метода  для массового обновления записей</span></a>Использование метода <code>update()</code> для массового обновления записей</h3>\n<p>Метод <code>update()</code> особенно полезен, когда вам нужно обновить большое количество записей одним запросом. Это может значительно повысить производительность по сравнению с индивидуальным обновлением каждого объекта через метод <code>save()</code>.</p>\n<p>Пример массового обновления года издания для всех книг с названием \"The Great Gatsby\":</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\">Book.objects.<span class=\"hljs-built_in\">filter</span>(title=<span class=\"hljs-string\">\"The Great Gatsby\"</span>).update(year=<span class=\"hljs-number\">2021</span>)\n\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"102\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-102\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-102\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-102.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Этот код обновит год издания на 2021 для всех книг с названием \"The Great Gatsby\" в базе данных одним запросом.</p>\n<h3 id=\"sostoyanie-gonki-i-kak-s-nim-borotsya\"><a href=\"#sostoyanie-gonki-i-kak-s-nim-borotsya\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">Состояние гонки и как с ним бороться</span></a>Состояние гонки и как с ним бороться</h3>\n<p>Состояние гонки (race condition) возникает, когда два или более процессов одновременно пытаются читать и изменить одни и те же данные в базе данных, что  может привести к непредсказуемым результатам и повреждению данных. В контексте обновления данных состояние гонки может произойти, если одновременно несколько запросов пытаются обновить одну и ту же запись.</p>\n<p>Использование комбинации <code>get</code> и <code>save</code> для обновления объекта подвержено риску возникновения состояния гонки, так как между получением объекта и его сохранением данные могут быть изменены другим процессом.</p>\n<p>Пример использования <code>get</code> и <code>save</code>:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\">book = Book.objects.get(title=<span class=\"hljs-string\">\"The Great Gatsby\"</span>)\nbook.year = <span class=\"hljs-number\">2021</span>  <span class=\"hljs-comment\"># В этот момент времени, кто-то может в БД обновить запись</span>\nbook.save()\n\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"118\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-118\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-118\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-118.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>В этом случае, если другой процесс обновит запись после того, как <code>book</code> был получен и перед тем, как он был сохранен, изменения, внесенные первым процессом, будут утеряны.</p>\n<p>Использование <code>filter</code> и <code>update</code> позволяет избежать этой проблемы, выполняя обновление атомарно на уровне базы данных:</p>\n\n    <div class=\"yfm-clipboard\">\n    <pre><code class=\"hljs python\">Book.objects.<span class=\"hljs-built_in\">filter</span>(title=<span class=\"hljs-string\">\"The Great Gatsby\"</span>).update(year=<span class=\"hljs-number\">2021</span>)\n</code></pre>\n\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-button\" data-animation=\"125\">\n        <path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>\n        <path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\">\n            <animate id=\"visibileAnimation-125\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin></animate>\n            <animate id=\"hideAnimation-125\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-125.end+1\" fill=\"freeze\"></animate>\n        </path>\n    </svg>\n    </div>\n<p>Такой подход гарантирует, что все соответствующие записи будут обновлены одним запросом, что минимизирует риск состояния гонки и делает обновление более надежным и эффективным.</p>\n<h3 id=\"update-vs-save\"><a href=\"#update-vs-save\" class=\"yfm-anchor\" aria-hidden=\"true\"><span class=\"visually-hidden\">update vs save</span></a>update vs save</h3>\n<p>Давайте сравним использования методов <code>update()</code> и <code>save()</code> для обновления объектов в Django, чтобы наглядно представить их преимущества и оптимальные сценарии использования.</p>\n<table>\n<thead>\n<tr>\n<th>Критерий</th>\n<th>update()</th>\n<th>save()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Назначение</td>\n<td>Массовое обновление объектов на уровне базы данных.</td>\n<td>Обновление отдельных экземпляров модели с возможностью дополнительной логики.</td>\n</tr>\n<tr>\n<td>Производительность</td>\n<td>Высокая производительность при работе с большими объемами данных.</td>\n<td>Ниже, чем у update(), особенно при обновлении большого количества объектов.</td>\n</tr>\n<tr>\n<td>Использование</td>\n<td>Идеально подходит для обновления множества объектов одним и тем же значением.</td>\n<td>Подходит для ситуаций, когда необходимо выполнить дополнительные действия перед сохранением или после него.</td>\n</tr>\n<tr>\n<td>Гибкость</td>\n<td>Ограничена. Не позволяет выполнение дополнительной логики на уровне модели.</td>\n<td>Высокая. Позволяет выполнение валидации, обновление специальных полей, обработку сигналов.</td>\n</tr>\n<tr>\n<td>Автоматическое обновление полей</td>\n<td>Не поддерживает автоматическое обновление полей, таких как auto_now.</td>\n<td>Автоматически обновляет поля, такие как auto_now и auto_now_add.</td>\n</tr>\n<tr>\n<td>Сигналы</td>\n<td>Сигналы модели, такие как pre_save и post_save, не отправляются.</td>\n<td>Отправляет соответствующие сигналы модели, поддерживая сложную логику приложения.</td>\n</tr>\n</tbody>\n</table>\n"},"router":{"pathname":"Основы ORM в Django/CRUD операции/Создание и обновление объектов/task.html"},"lang":"ru","langs":["ru"]};
                </script>
                <script type="application/javascript" src="../_bundle/react.js"></script>
<script type="application/javascript" src="../_bundle/app.js"></script>
<script type="application/javascript" src="../_bundle/vendor.js"></script>
            </body>
        </html>
    